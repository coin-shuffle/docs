<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Coin Shuffle Documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="protocol/index.html"><strong aria-hidden="true">1.</strong> Protocol</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="protocol/introduction.html"><strong aria-hidden="true">1.1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="protocol/overview.html"><strong aria-hidden="true">1.2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="protocol/practical-example.html"><strong aria-hidden="true">1.3.</strong> Practical Example</a></li><li class="chapter-item expanded "><a href="protocol/vulnerabilities.html"><strong aria-hidden="true">1.4.</strong> Drawbacks</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Coin Shuffle Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="protocol"><a class="header" href="#protocol">Protocol</a></h1>
<p>This chapter provides an overview of the protocol used by the <strong>Coin Shuffle</strong>
with diagrams and explanations about communication algorithms.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>The <strong>Coin Shuffle</strong> protocol tries to solve the problem of <strong>privacy</strong> in the
decentralized network by providing a <strong>trustless</strong> way to shuffle tokens between
multiple addresses in a way that the <strong>history</strong> of the shuffling is
<strong>untraceable</strong>.</p>
<p>Protocol is based on the <strong>UTXO</strong> (unspent transaction output) model (which is used,
for example, in Bitcoin). In this model, each token is represented by a
<strong>transaction output</strong> - proof that a certain amount of tokens was sent to a
certain address (usually, a hash of the transaction in which UTXO was created).</p>
<p>The <strong>Coin Shuffle</strong> protocol enables a group of users to combine their unspent
transaction outputs (UTXOs) and shuffle them in a manner that ensures the
resulting tokens are sent to different addresses in batch while keeping the
association between the original <strong>inputs</strong> and the new <strong>outputs</strong>
confidential.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>For further explanation, we will use the following terms:</p>
<ul>
<li><strong>Participant</strong> - a user that wants to shuffle his UTXOs.</li>
<li><strong>Input</strong> - a UTXO that the participant wants to shuffle, spent.</li>
<li><strong>Output</strong> - an address that will receive a UTXO after shuffling.</li>
<li><strong>Encrypted Outputs</strong> - a list of <strong>outputs</strong> encrypted by RSA secret key. </li>
<li><strong>Service</strong> - a service that provides <strong>coordination</strong> logic for participants
without any ability to reveal <strong>output</strong> addresses or steal <strong>UTXO</strong>s.</li>
<li><strong>Room</strong> - a group of participants that are currently shuffling their <strong>UTXO</strong>s.</li>
</ul>
<p>The shuffling process is done in the following steps:</p>
<ol>
<li><strong>Participants Registration</strong>. Participants register in the <strong>service</strong> by providing
their ownership proof of <strong>UTXO</strong>s that they want to spend.</li>
<li><strong>Shuffle start</strong>. <strong>Service</strong> waits for enough participants to register and
then starts the shuffling process.</li>
<li><strong>Participants connection</strong>. Participants send their RSA public keys to the
<strong>service</strong> to notify service that they are ready for shuffling.</li>
<li><strong>Keys distribution</strong> - <strong>service</strong> defines order of shuffling and sends RSA
public keys that are required for participants to decrypt <strong>encrypted
outputs</strong>.</li>
<li><strong>Shuffling</strong>.
<ol>
<li>First participant encrypts his <strong>output</strong> with the RSA public keys of the next
participants, in order, that each next participant will be able to decrypt
its upper &quot;layer&quot; of encryption. Then, the participant sends <strong>encrypted
output</strong> to the <strong>service</strong>.</li>
<li>Next participant decrypts <strong>encrypted outputs</strong> of the previous
participant and encrypts his <strong>output</strong> with RSA public keys of next
participants and sends new <strong>encrypted outputs</strong> to the <strong>service</strong>.</li>
<li>This process continues until the last participant will get a list of
<strong>outputs</strong> without any encryption.</li>
</ol>
</li>
<li><strong>Transaction distribution</strong>. After the last participant sends a fully decrypted
outputs to the <strong>service</strong>, <strong>service</strong> forms a transaction, that each
the participant should sign.</li>
<li><strong>Transaction signing</strong>. Each participant verifies a transaction,
sees that has <strong>input</strong> and <strong>output</strong> are included, signs it, and sends
signature to the <strong>service</strong>.</li>
<li><strong>Transaction sending</strong>. <strong>Service</strong> gathers all signatures and sends
transaction to the network.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="practical-example"><a class="header" href="#practical-example">Practical Example</a></h1>
<p>Assume we have 5 participants that want to shuffle their <strong>UTXO</strong>s. Each
participant has a <strong>UTXO</strong> with the same <strong>ERC20</strong> tokens and <strong>amount</strong>, for
example 5 USDT tokens, and they want to shuffle them to 5 unknown addresses.</p>
<p>Lets name them <strong>Alice</strong>, <strong>Bob</strong>, <strong>Charlie</strong>, <strong>David</strong>, and <strong>Eve</strong>:</p>
<pre class="mermaid">flowchart TB
    Alice
    Bob
    Charlie
    David
    Eve
</pre>
<p><strong>Alice</strong>, <strong>Bob</strong>, <strong>Charlie</strong>, <strong>David</strong>, and <strong>Eve</strong> want to send their
UTXOs to some 5 addresses, and they don't want to reveal receivers of that UTXOs
to anybody. So, for coordination, they will use a <strong>service</strong> which implements
<strong>Coin Shuffle</strong> protocol.</p>
<pre class="mermaid">flowchart TB
    Alice --- Service
    Bob --- Service
    Charlie --- Service
    David --- Service
    Eve --- Service
</pre>
<p><strong>Alice</strong>, <strong>Bob</strong>, <strong>Charlie</strong>, <strong>David</strong>, and <strong>Eve</strong> will register in the
<strong>service</strong> by providing their <strong>UTXO</strong>s with proof of ownership.</p>
<p>Service will organize them into <strong>queue</strong> until enough participants will be
registered.</p>
<blockquote>
<p>In this example, we will assume that 5 participants are enough to shuffle.</p>
</blockquote>
<pre class="mermaid">flowchart TB
    Alice --&gt; alice_utxo(5$A + Alice's signature)
    Bob --&gt; bob_utxo(5$B + Bob's signature)
    Charlie --&gt; charlie_utxo(5$C + Charlie's signature)
    David --&gt; david_utxo(5$D + David's signature)
    Eve --&gt; eve_utxo(5$E + Eve's signature)
    alice_utxo --&gt; Service
    bob_utxo --&gt; Service
    charlie_utxo --&gt; Service
    david_utxo --&gt; Service
    eve_utxo --&gt; Service
    
    Service --&gt; queue[[Queue: E, A, D, B, C]]
</pre>
<p>Then, when enough participants will be registered, <strong>service</strong> will form a <strong>room</strong>,
and notify the participants, so they can send their RSA public keys.</p>
<pre class="mermaid">flowchart TB
    Service --&gt; room[[Room: A, B, C, D, E]]
</pre>
<p>As a response, participants will send their RSA public keys to the <strong>service</strong>:</p>
<pre class="mermaid">flowchart TB
    Alice --&gt; alice_pk(Alice's RSA public key)
    Bob --&gt; bob_pk(Bob's RSA public key)
    Charlie --&gt; charlie_pk(Charlie's RSA public key)
    David --&gt; david_pk(David's RSA public key)
    Eve --&gt; eve_pk(Eve's RSA public key)
    alice_pk --&gt; Service
    bob_pk --&gt; Service
    charlie_pk --&gt; Service
    david_pk --&gt; Service
    eve_pk --&gt; Service
</pre>
<p><strong>Service</strong> will define the order of shuffling and send RSA public keys that are
required for <strong>outputs</strong> <strong>encoding</strong> and <strong>decoding</strong> to each participant:</p>
<pre class="mermaid">flowchart TB
    Service --&gt; alice_keys[[Alice's keys: B, C, D, E]]
    Service --&gt; bob_keys[[Bob's keys: C, D, E]]
    Service --&gt; charlie_keys[[Charlie's keys: D, E]]
    Service --&gt; david_keys[[David's keys: E]]
    Service --&gt; eve_keys[[Eve's keys:]]
    alice_keys --&gt; Alice
    bob_keys --&gt; Bob
    charlie_keys --&gt; Charlie
    david_keys --&gt; David
    eve_keys --&gt; Eve
</pre>
<blockquote>
<p>Note, that each participant already knows his public key.</p>
</blockquote>
<p>Table of <strong>keys</strong> that each participant has:</p>
<div class="table-wrapper"><table><thead><tr><th>Key / Participant</th><th>Alice</th><th>Bob</th><th>Charlie</th><th>David</th><th>Eve</th></tr></thead><tbody>
<tr><td>Alice</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td>Bob</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td>Charlie</td><td>❌</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td>David</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td><td>✅</td></tr>
<tr><td>Eve</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td></tr>
</tbody></table>
</div>
<p>Then <strong>service</strong> will send <strong>encrypted outputs</strong> to each participant, starting
with <strong>Alice</strong>:</p>
<blockquote>
<p>Alice is the first participant in the <strong>room</strong>, so she will receive list of
empty encrypted <strong>inputs</strong>, and  encrypt her <strong>output</strong>.</p>
</blockquote>
<p>Firstly, <strong>Alice</strong> will encrypt her <strong>output</strong> with her public keys:</p>
<pre class="mermaid">flowchart LR
    alice_output[&quot;@A&quot;]-- Eve's key --&gt;alice_output1[&quot;E[ @A ]&quot;]
    alice_output1-- David's key --&gt;alice_output2[&quot;D[ E[ @A ] ]&quot;]
    alice_output2-- Charlie's key --&gt;alice_output3[&quot;C[ D[ E[ @A ] ] ]&quot;]
    alice_output3-- Bob's key --&gt;alice_output4[&quot;B[ C[ D[ E[ @A ] ] ] ]&quot;]
</pre>
<p>Then, <strong>Alice</strong> will send <strong>encrypted output</strong> to <strong>Bob</strong> through <strong>service</strong>.
<strong>Bob</strong> knows, that received <strong>encrypted output</strong> is encrypted with his RSA
the public key, so he will decrypt it using his secret key:</p>
<pre class="mermaid">flowchart LR
    alice_output3[&quot;B[ C[ D[ E[ @A ] ] ] ]&quot;]-- Bob's secret key --&gt;bob_output1[&quot;C[ D[ E[ @A ] ] ]&quot;]
</pre>
<p>Then <strong>Bob</strong> will encrypt his <strong>output</strong> with his public keys:</p>
<pre class="mermaid">flowchart LR
    bob_output[&quot;@B&quot;] -- Eve's key --&gt;bob_output1[&quot;E[ @B ]&quot;]
    bob_output1 -- David's key --&gt;bob_output2[&quot;D[ E[ @B ] ]&quot;]
    bob_output2 -- Charlie's key --&gt;bob_output3[&quot;C[ D[ E[ @B ] ] ]&quot;]
</pre>
<p>Then, <strong>Bob</strong> will shuffle them, and send <strong>encrypted outputs</strong> to <strong>Charlie</strong> through <strong>service</strong>.</p>
<pre class="mermaid">flowchart LR
    Bob --- bobs_outputs[[&quot;C[ D[ E[ @B ] ] ] &lt;br&gt; C[ D[ E[ @A ] ] ]&quot;]]
    bobs_outputs --&gt; Service
    Service --&gt; Charlie
</pre>
<p><strong>Charlie</strong> will decrypt its upper layers with her secret key:</p>
<pre class="mermaid">flowchart LR
    bobs_outputs[&quot;C[ D[ E[ @A ] ] ]&lt;br&gt; C[ D[ E[ @B ] ] ]&quot;]-- Charlie's secret key --&gt;charlie_output1[&quot;D[ E[ @A ] ]&lt;br&gt; D[ E[ @B ] ]&quot;]
</pre>
<p>Then <strong>Charlie</strong> will encrypt her <strong>output</strong> with her public keys:</p>
<pre class="mermaid">flowchart LR
    charlie_output[&quot;@C&quot;] -- Eve's key --&gt;charlie_output1[&quot;E[ @C ]&quot;]
    charlie_output1 -- David's key --&gt;charlie_output2[&quot;D[ E[ @C ] ]&quot;]
</pre>
<p>Shuffle them, and send them to <strong>David</strong>:</p>
<pre class="mermaid">flowchart LR
    Charlie --- charlies_outputs[[&quot;D[ E[ @A ] ] &lt;br&gt; D[ E[ @C ] ] &lt;br&gt; D[ E[ @B ] ]&quot;]]
    charlies_outputs --&gt; Service
    Service --&gt; David
</pre>
<p>The process will continue until <strong>Eve</strong> will receive <strong>encrypted outputs</strong> from
<strong>David</strong>. <strong>Eve</strong> will finally get fully decrypted <strong>outputs</strong> from all
participants:</p>
<pre class="mermaid">flowchart LR
    davids_outputs[&quot;E[ @C ]&lt;br&gt; E[ @D ]&lt;br&gt; E[ @A ]&lt;br&gt; E[ @B ]&quot;]-- Eve's secret key --&gt;eve_output1[&quot;@C&lt;br&gt; @D&lt;br&gt; @A&lt;br&gt; @B&quot;]
</pre>
<p><strong>Eve</strong> will send that <strong>outputs</strong> to <strong>service</strong>, <strong>service</strong> will
form transaction with all <strong>inputs</strong> and <strong>outputs</strong>, and send it to
all participants for signing.</p>
<pre class="mermaid">flowchart TB
    Service --&gt; transaction[[&quot;Transaction. &lt;br&gt; Inputs: $5D, $5C, $5B, $5A, $5E &lt;br&gt; Outputs: @C, @D, @A, @B, @E&quot;]]
    transaction --&gt; Alice
    transaction --&gt; Bob
    transaction --&gt; Charlie
    transaction --&gt; David
    transaction --&gt; Eve
</pre>
<p>Each participant will see, that transaction is valid and at least contains
their input and output, so they will sign it and send it back to <strong>service</strong>.</p>
<p>The <strong>service</strong> will gather all required signatures, and then send them to the network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h1>
<h2 id="coordinator"><a class="header" href="#coordinator">Coordinator</a></h2>
<p>In this implementation, <strong>service</strong> is a trusted server, that coordinates
participants. Although the <strong>coordinator</strong> is not able to reveal the private
information of the participants, it can still prevent the protocol from starting
or completing.</p>
<p>A possible solution is to make an open, decentralized implementation of <strong>service</strong>,
that can be run and trusted by anyone.</p>
<h2 id="sybil-attack"><a class="header" href="#sybil-attack">Sybil attack</a></h2>
<p>Participants can collaborate in the room, to reveal the identities of other
participants.</p>
<p>For example, if 4 of 5 participants are malicious, they can reveal the identity
of the last participant, by revealing their outputs to each other.</p>
<p>A possible solution is to make a much larger number of participants in shuffling
process, so that the probability of a such attack is very low.</p>
<p>The other solution is to make an unpredictable, random algorithm that will distribute
participants into smaller &quot;rooms&quot; which will shuffle separately.</p>
<h2 id="timing-attacks"><a class="header" href="#timing-attacks">Timing attacks</a></h2>
<p>The protocol implementation relies on network communication with its latencies
and possible disconnections during the protocol execution. That's why one of the
participants can repeatably disrupt the protocol execution, by disconnecting.</p>
<h2 id="sudoku-analysis"><a class="header" href="#sudoku-analysis">Sudoku analysis</a></h2>
<p>While Coin Shuffle provides a reasonable level of privacy, users still need to
be careful about not revealing their identity through their actions. For
example, if the user will send his tokens to the same address from different
shuffling processes, some external viewers can easily analyze the history of the
transactions and participants of the recent shuffling, and reveal the identity
of the user by Sudoku analysis or even just intercept inputs' and outputs'
addresses of the transactions.</p>
<p>The only solution is to use new separate output addresses for each
shuffling process.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
